# react

- 数据驱动
- 在javascript中编写html代码
- 鼓励函数式编程
> 变量能做的，函数一样可以

- 从package.json安装依赖时，建议yarn替代npm

## 函数式编程

1. 不可变性
> 在不修改原生数据结构的前提下，我们在这些数据结构的拷贝上进行编辑

1. 纯函数
> 至少接收一个参数，并且总是返回一个值或函数，一样不会产生副作用。他们将输入的参数当作不可变数据

1. 数据转换
> 将一种数据转换成另外一种数据，我们使用函数生成转换后的副本

1. 高阶函数
> 可以将函数当作参数传递，也可以返回一个函数，或者两者都有
> 柯里化实际上是一种将某个操作中已完成的结果保留，指导其余部分也完成后一并提供的机制

1. 递归
> 函数调用自身，涉及到循环时，递归函数可以提供替代性方案
> 递归是另外一个很好处理异步过程的的函数式编程技术
> 递归是一种非常强大的函数式编程技巧，并且易于实现，建议处理循环时尽量使用递归

1. 合成
> 将具体的业务逻辑拆分成小型的纯函数，以便能够将精力聚焦于特定任务
> 合成方式很多种，如链式调用
> 合成的目标：通过整合若干简单函数构造一个更高阶的函数

1. #总结#
> 保持数据的不可变性
> 确保尽量使用纯函数，只接收一个函数，返回数据或其他函数
> 尽量使用递归处理循环
> 尽量使用函数代替变量赋值
> 用高阶函数来创建函数

``` js
const compose = (...fns) =>
  (arg) =>
    fns.reduce(
      (composed, f) => f(composed),
      arg
    )

```

### react 进阶

1. AJAX技术的兴起也导致了单页应用（SPA）的出现。

2. DOM API 是一组对象集合，JavaScript可以通过它们和浏览器交互并修改DOM。

3. 在JavaScript中更新或修改已经渲染过的DOM相对来说更容易一些。不过插入新元素的过程非常低效。

4. 虚拟DOM是由react元素组成的，概念上和HTML元素类似，不过他们实际上是JavaScript对象。直接访问JavaScript对象要比访问DOM API高效的多。我们可以修改JavaScript对象，即虚拟DOM，然后react通过DOM API 为用户尽可能高效的渲染这些变更。

5. 浏览器的DOM是由DOM元素构成的。同样，react的DOM是由react元素构成的

6. 一个react元素是对实际DOM元素应该如何表示的具体描述。换句话说，react元素表示应该如何创建浏览器DOM的一组指令。

7. 一个react元素只是一个JavaScript语法，用来告知react如何构造DOM元素

8. 本章介绍使用createElement和CreatFactory方法构建组件，接下来介绍JSX简化构建组建的过程

### JSX

1. className 代替 class

1. JSX是JavaScript代码，因此可以直接将JSX集成到JavaScript函数内部

``` js
  <ul className="ingredients">
      {ingredients.map((ingredient, i) =>
          <li key={i}>{ingredient.name}</li>
      )}
  </ul>
```

1. 将JSX转换成浏览器可解析的格式叫转译，这也是Babel的主要功能

1. 将Babel和webpack一起搭配使用，可以对JavaScript进行静态转译

1. 使用ES6规范中的对象解构，我们可以让组件通过名称将这些字段的作用域本地化

1. 模块化绑定的两个主要优点是模块化和网络性能。

1. 模块化使得用户可以将源代码分解成易于使用的部分或模块，特别是对于团队开发来说，特别有用。

1. 网络性能的优点在于浏览器只需载入依赖即可。将所有的依赖打包成单个文件后，只需发送一次http请求，就能加载所有必须资源。避免额外的网络延迟。

1. webpack还可以处理

    - 代码拆分
    > 将代码拆分成不同的片段，使得用户可以按需加载它们。起目标是为不同页面或者设备的需要对代码进行拆分打包
    - 代码压缩
    - 特性标记
    - 热替换

1. 较小的组件更容易理解，测试和复用。在需要对应用程序进行性能扩展时，他们也更容易替换

1. webpack 的默认配置文件始终是`webpack.config.js`

1. 源代码映射文件`.map`就是一个描述已打包的bundle文件和原来的源代码一一对应的关系的文件

### Props、State和组件树

1. 如果能够从单一数据源管理数据，并且基于上述数据构建UI，那么我们的应用程序将会更容易理解和扩展。

1. JavaScript是弱类型语言，也就是说可以修改变量值的数据类型，但是低效的管理我们的变量类型会导致花费大量时间在调试应用程序上。

1. 自定义验证属性可以执行多重验证，只在不符合某些特定规则时返回错误。

1. 最好在每个组件都实现属性验证、自定义属性验证，以及设置默认属性值等功能。这样一来，复用组件就更容易了，因为任何与组件属性有关的的问题都会在控制台输出警告信息。

1. 当用户和一个应用程序交互时，应用程序的State也随之变化，同时这些变化又以UI的变化反馈给用户

1. 让应用程序易于理解的关键之一是尽可能减少使用State的组件数量

1. 表现层组件只关心应用程序的外观。它们只渲染DOM元素或者其他表现层组件

1. render方法会在每次调用setState方法之后触发。新的数据将会以属性的形式在组件树中向下传递，然后用于构造UI。

1. 一旦setState方法被调用，UI就会根据新的State数据重新被渲染。整个应用程序中的所有数据变更都是通过单个组件进行管理的，即App。这种方法使得用户更容易理解应用程序使用了哪些数据创建State，以及数据是如何变化的

### 组件扩展

1. 生命周期即每次我们挂载或更新组件过程中一系列可以调用的方法。

1. render方法本身就是组件生命周期的一部分。有两种主要的生命周期：挂载生命周期和更新生命周期。

1. 当用户使用creatClass时，getDefaultProps方法会被触发首先获得组件的属性。然后，getInitialState方法将会被触发，用于初始化State。

1. 一旦属性被获取并且也初始化了State，componentWillMount方法将被触发。该方法是在DOM被渲染之前触发的， 并且可以用来初始化第三方脚本库、启动动画、请求数据、以及其他可能需要在组件被渲染之前执行的额外步骤。还可以在该方法中触发setState方法，在组建被初次渲染之前修改组件的State。

1. componentDidMount方法是另外一个创建API请求的好地方。该方法会在组件渲染完毕之后触发，该方法中的任意setState方法调用都将启动更新生命周期，并且重新渲染组件。该方法也是初始化任何需要用到DOM的第三方JavaScript的好地方。

1. componentWillUnmount可以用于清除诸如intervals或者timers这样的后台进程。

1. 当一个根组件被卸载时，它的子组件将会首先被卸载

1. 更新生命周期会在每次调用setState方法之后启动，在更新生命周期方法中，只有componentWillReceiveProps方法内部调用才能setState方法。

1. componentWillReceiveProps 仅当新的属性被传递给了组件后才会调用。

1. 重写渲染组件并不是重新挂载，如果它们已经存在那里，更新将会替代挂载。当一个组件被更新了，它的所有子元素也被更新了

1. shouldComponentUpdata方法可以比较新旧属性之间的差异。新属性会作为参数传给该方法，旧属性仍然在当前的props中，并且该组件还未被更新。

1. componentsWillUpdate和componentsDidupdate是更新之前或者之后与DOM交互的好地方

1. componentWillReceiveProps生命周期方法会在属性被伏组件修改时触发。并且这些变更的属性可以用来修改内部的State

1. React.Childern提供了一种可以访问特定组件子元素的方法。它允许用户统计、映射、循环、或者将props.children转换成一个数组。它还允许用户使用React.Children.only对正在显示的单个子节点进行验证

1. React只是一个简单的创建视图的脚本库，因此我们需要将它和其他JavaScript脚本库搭配使用

1. 我们可以将任意JavaScript库与React集成。生命周期函数是其他JavaScript库进入，React库离开的地方。不过我们应该竭力避免添加管理UI的脚本库，这是React的工作。

1. 高阶组件是一个简单的函数，他会接收一个React组件作为参数，然后返回另外一个React组件。通常，HOC会使用一个能够维护State或者包含若干功能的类来包装输入的组件。高阶组件是组件之间功能复用的最佳方式。（实现vue Mixin 类似的功能）

1. 高阶组件能够将组件State和生命周期管理细节封装起来。它允许用户构建更多无状态函数式组件，以便可以一心一意的管理UI

### Redux

1. Redux是基于Flux的，旨在处理应用程序中数据流变化的问题。

1. 通过Redux，我们将State管理和React完全剥离，Redux将会管理这些State

1.在构建Redux应用时，用户首先需要考虑的事情就是State树。尝试在单个对象中定义State。使用一些占位符数据草拟一个State树的JSON示例是一个非常好的习惯。

1.Auction是更新Redux应用程序State的唯一方式。

1. Redux是通过函数来进行模块化的。函数被用来更新部分State树中的内容。这些函数被称为Reducer。

1. 使用Reducer时，最好将State当作不可变对象。

1. 在Redux中，Store就是保存应用程序State数据和处理所有State更新的地方。

1. 总之，Store是Redux应用程序中保存和管理State数据的地方，也是通过Store分发Action的形式，唯一的修改State数据的方式。Store会将应用程序的State作为单个对象进行保存。State的变更是通过Reducer来完成的。Store的创建是通过提供一个Reducer和可选的出事State数据完成的。

1. Action生成器应该是存放所有和后端API交互逻辑相关内容的地方。通过一个Action生成器，我们可以执行异步逻辑，比如请求数据或发送一个API请求。

1. Redux的中间件扮演了Store的分发管道角色。在Redux中，中间件是在分发某个Action过程中一系列顺序执行的若干函数构成，中间件可以作为两个不同层次或者不同软件之间的粘合剂。

### 测试
